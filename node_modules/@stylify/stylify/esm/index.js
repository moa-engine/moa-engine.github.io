/**
*	(c) 2021-present Vladimír Macháček
*	Released under the MIT License.
*/
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// packages/stylify/src/Utilities/colors.ts
var lightenDarkenColor = (color, amount) => {
  const { r, g, b } = parseColor(color);
  const colors = [r, g, b].map((colorPart) => {
    colorPart += amount;
    if (colorPart > 255) {
      colorPart = 255;
    } else if (colorPart < 0) {
      colorPart = 0;
    }
    return colorPart;
  });
  return rgbToHex({
    r: colors[0],
    g: colors[1],
    b: colors[2]
  });
};
var parseHex = (color) => {
  const hex = color.replace("#", "");
  const isHexThreeCharsLong = hex.length === 3;
  return {
    r: parseInt(isHexThreeCharsLong ? hex.slice(0, 1).repeat(2) : hex.slice(0, 2), 16),
    g: parseInt(isHexThreeCharsLong ? hex.slice(1, 2).repeat(2) : hex.slice(2, 4), 16),
    b: parseInt(isHexThreeCharsLong ? hex.slice(2, 3).repeat(2) : hex.slice(4, 6), 16)
  };
};
var parseRgb = (color) => {
  color = color.replace("rgb(", "").replace(/\)/, "");
  const colorToArray = color.split(color.includes(",") ? "," : " ");
  return {
    r: parseInt(colorToArray[0]),
    g: parseInt(colorToArray[1]),
    b: parseInt(colorToArray[2])
  };
};
var parseColor = (color) => {
  let rgbData = {
    r: null,
    g: null,
    b: null
  };
  if (/^#/.test(color)) {
    rgbData = parseHex(color);
  } else if (/^rgb\(/.test(color)) {
    rgbData = parseRgb(color);
  }
  if (rgbData.r === null) {
    throw new Error(`Color "${color}" could not be converted to RGB.`);
  }
  return rgbData;
};
var rgbToHex = (color) => {
  if (typeof color === "string") {
    color = parseRgb(color);
  }
  const { r, g, b } = color;
  return "#" + [r, g, b].map((colorPart) => {
    const hex = colorPart.toString(16);
    return hex.length == 1 ? `0${hex}` : hex;
  }).join("");
};

// packages/stylify/src/Utilities/numbers.ts
var createUId = () => Date.now().toString(36) + Math.random().toString(36).substring(2);

// packages/stylify/src/Utilities/objects.ts
var mergeObjects = (...objects) => {
  const mergedObject = {};
  for (const objectToMerge of objects) {
    for (const [key, value] of Object.entries(objectToMerge)) {
      if (!(key in mergedObject)) {
        mergedObject[key] = value;
        continue;
      }
      const valueType = typeof value;
      if (Array.isArray(value)) {
        mergedObject[key] = [...mergedObject[key], ...value];
      } else if (value !== null && valueType === "object") {
        mergedObject[key] = mergeObjects(mergedObject[key], value);
      } else {
        mergedObject[key] = value;
      }
    }
  }
  return mergedObject;
};

// packages/stylify/src/Utilities/strings.ts
var dollarPlaceholder = "_DLR_";
var backslashPlaceholder = "_BSLASH_";
var escapeCssSelector = (selector, all = false) => {
  const selectorLength = selector.length;
  let result = "";
  const regExp = all ? /[^a-zA-Z0-9]/ : /[.*+?^${}()|[\]\\]/;
  for (let i = 0; i < selectorLength; i++) {
    const char = selector[i];
    const escapeCharacter = "\\";
    if (["-", "_"].includes(char) || !regExp.test(char) || selector[i - 1] === escapeCharacter) {
      result += char;
      continue;
    }
    result += `\\${char}`;
  }
  return result;
};
var tokenize = (content, tokenizerCallback) => {
  const tokens = content.split("");
  const tokensCount = tokens.length;
  for (let i = 0; i < tokensCount; i++) {
    if (tokenizerCallback({
      token: tokens[i],
      nextToken: tokens[i + 1],
      previousToken: tokens[i - 1],
      iterator: i,
      isLastToken: i + 1 === tokensCount,
      isFirstToken: i === 0,
      tokensCount
    })) {
      break;
    }
  }
};
var dollarPlaceholderRegExp = new RegExp(dollarPlaceholder, "g");
var backslashPlaceholderRegExp = new RegExp(backslashPlaceholder, "g");
var prepareStringForReplace = (content) => {
  return content.replace(/\$/g, dollarPlaceholder).replace(/\\/g, backslashPlaceholder);
};
var getStringOriginalStateAfterReplace = (content) => {
  return content.replace(dollarPlaceholderRegExp, "$$").replace(backslashPlaceholderRegExp, "\\");
};

// packages/stylify/src/Hooks.ts
var hookListeners = {};
var Hooks = class {
  addListener(hookName, callback) {
    if (!(hookName in hookListeners)) {
      hookListeners[hookName] = [];
    }
    hookListeners[hookName].push(callback);
  }
  callHook(hookName, data) {
    var _a;
    const hookData = this.createHookData(data);
    for (const hookCallback of (_a = hookListeners[hookName]) != null ? _a : []) {
      hookCallback(hookData);
    }
    return hookData;
  }
  callAsyncHook(hookName, data) {
    return __async(this, null, function* () {
      const hookData = this.createHookData(data);
      const callHook = (id = 0) => __async(this, null, function* () {
        var _a, _b;
        const hook = (_b = ((_a = hookListeners[hookName]) != null ? _a : [])[id]) != null ? _b : null;
        if (!hook) {
          return;
        }
        const hookResult = hook(hookData);
        if (hookResult instanceof Promise) {
          yield hookResult;
        }
        return callHook(id + 1);
      });
      yield callHook();
      return hookData;
    });
  }
  createHookData(data) {
    return __spreadValues({}, data);
  }
};
var hooks = new Hooks();

// packages/stylify/src/Compiler/Compiler.ts
var Compiler = class {
  constructor(config = {}) {
    __publicField(this, "macroRegExpStartPart", "(?:^|[^a-zA-Z0-9_-])");
    __publicField(this, "macroRegExpEndPart", `(?=['"\`{}\\[\\]<>\\s]|$)`);
    __publicField(this, "variableRegExp", /\$([\w-_]+)/g);
    __publicField(this, "contentOptionsRegExp", /stylify-([a-zA-Z-_0-9]+)\s([\s\S]+?)\s\/stylify-[a-zA-Z-_0-9]+/);
    __publicField(this, "macrosRegExpGenerators", [
      // Match with media query and without pseudo class
      (macroKey) => new RegExp(`([a-zA-Z0-9\\-:&\\|]+):${macroKey}${this.macroRegExpEndPart}`, "g"),
      // Match without media query and without pseudo class
      // () - empty pseudo class and media query match
      (macroKey) => new RegExp(`()${macroKey}${this.macroRegExpEndPart}`, "g")
    ]);
    __publicField(this, "undefinedVariableWarningLevel", "error");
    __publicField(this, "rewrittenAreasCache", {});
    __publicField(this, "ignoredAreas", []);
    __publicField(this, "mangleSelectors", false);
    __publicField(this, "mangledSelectorsPrefix", "");
    __publicField(this, "selectorsPrefix", "");
    __publicField(this, "dev", false);
    __publicField(this, "macros", {});
    __publicField(this, "helpers", {});
    __publicField(this, "screens", {});
    __publicField(this, "variables", {});
    __publicField(this, "externalVariables", []);
    __publicField(this, "keyframes", {});
    __publicField(this, "components", {});
    __publicField(this, "pregenerate", "");
    __publicField(this, "selectorsAreas", []);
    __publicField(this, "customSelectors", {});
    __publicField(this, "matchCustomSelectors", true);
    __publicField(this, "processedHelpers", {});
    __publicField(this, "cssVariablesEnabled", true);
    __publicField(this, "injectVariablesIntoCss", true);
    /** @internal */
    __publicField(this, "ignoredAreasRegExpString", null);
    this.configure(defaultPreset);
    if (Object.keys(config).length) {
      this.configure(config);
    }
  }
  configure(config) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
    this.dev = (_a = config.dev) != null ? _a : this.dev;
    this.matchCustomSelectors = (_b = config.matchCustomSelectors) != null ? _b : this.matchCustomSelectors;
    this.macros = __spreadValues(__spreadValues({}, this.macros), (_c = config.macros) != null ? _c : {});
    this.helpers = __spreadValues(__spreadValues({}, this.helpers), (_d = config.helpers) != null ? _d : {});
    this.keyframes = __spreadValues(__spreadValues({}, this.keyframes), (_e = config.keyframes) != null ? _e : {});
    this.screens = __spreadValues(__spreadValues({}, this.screens), (_f = config.screens) != null ? _f : {});
    this.injectVariablesIntoCss = (_g = config.injectVariablesIntoCss) != null ? _g : this.injectVariablesIntoCss;
    this.selectorsAreas = [...this.selectorsAreas, ...(_h = config.selectorsAreas) != null ? _h : []];
    this.mangleSelectors = (_i = config.mangleSelectors) != null ? _i : this.mangleSelectors;
    this.mangledSelectorsPrefix = (_j = config.mangledSelectorsPrefix) != null ? _j : this.mangledSelectorsPrefix;
    this.selectorsPrefix = (_k = config.selectorsPrefix) != null ? _k : this.selectorsPrefix;
    this.undefinedVariableWarningLevel = (_l = config.undefinedVariableWarningLevel) != null ? _l : this.undefinedVariableWarningLevel;
    this.externalVariables = [...this.externalVariables, ...(_m = config.externalVariables) != null ? _m : []];
    this.cssVariablesEnabled = (_n = config.cssVariablesEnabled) != null ? _n : this.cssVariablesEnabled;
    this.addVariables((_o = config.variables) != null ? _o : {});
    if (typeof config.pregenerate !== "undefined") {
      this.pregenerate += Array.isArray(config.pregenerate) ? config.pregenerate.join(" ") : config.pregenerate;
    }
    const ignoredAreasRegExpStrings = [];
    this.ignoredAreas = [...this.ignoredAreas, ...(_p = config.ignoredAreas) != null ? _p : []].filter((ignoredAreaRegExp, index, self) => {
      const isUnique = self.indexOf(ignoredAreaRegExp) === index;
      if (isUnique)
        ignoredAreasRegExpStrings.push(ignoredAreaRegExp.source);
      return isUnique;
    });
    this.ignoredAreasRegExpString = ignoredAreasRegExpStrings.join("|");
    for (const [selector, selectorsToGenerate] of Object.entries((_q = config.customSelectors) != null ? _q : {})) {
      this.addCustomSelector(selector, selectorsToGenerate);
    }
    for (const [componentSelector, componentStringOrGenerator] of Object.entries((_r = config.components) != null ? _r : {})) {
      this.addComponent(componentSelector, componentStringOrGenerator);
    }
  }
  addVariables(variables, screen = null) {
    for (const [variableOrScreen, valueOrVariables] of Object.entries(variables)) {
      if (!["string", "number"].includes(typeof valueOrVariables)) {
        this.addVariables(valueOrVariables, variableOrScreen);
        continue;
      }
      const content = String(valueOrVariables);
      const processedValue = this.replaceVariableString(
        this.processHelpers({
          content,
          replaceByVariable: false,
          variablesScope: screen
        }),
        content
      );
      if (screen) {
        if (!(screen in this.variables)) {
          this.variables[screen] = {};
        }
        this.variables[screen][variableOrScreen] = processedValue;
        continue;
      }
      this.variables[variableOrScreen] = processedValue;
    }
  }
  addCustomSelector(selector, selectors, selectorCanBeSplit = true, type = "custom") {
    if (selectorCanBeSplit && selector.includes(",")) {
      selector.split(",").forEach((selectorSplit) => this.addCustomSelector(selectorSplit.trim(), selectors));
      return;
    }
    if (!(selector in this.customSelectors)) {
      this.customSelectors[selector] = {
        customSelectors: [],
        type
      };
    }
    this.customSelectors[selector].customSelectors.push(new CustomSelector(selectors));
  }
  addComponent(selector, selectorsOrGenerator) {
    if (selector.includes(",")) {
      selector.split(",").forEach((selector2) => this.addComponent(selector2.trim(), selectorsOrGenerator));
      return;
    }
    if (!(selector in this.components)) {
      this.components[selector] = {
        selectorsOrGenerators: []
      };
    }
    const isGenerator = typeof selectorsOrGenerator === "function";
    const definedSelectorsOrGenerators = this.components[selector].selectorsOrGenerators;
    if (!isGenerator && definedSelectorsOrGenerators.includes(selectorsOrGenerator)) {
      return;
    } else if (isGenerator) {
      for (const definedSelectorOrGenerator of definedSelectorsOrGenerators) {
        if (typeof definedSelectorOrGenerator !== "function") {
          continue;
        }
        if (definedSelectorOrGenerator.toString() === selectorsOrGenerator.toString()) {
          return;
        }
      }
    }
    this.components[selector].selectorsOrGenerators.push(selectorsOrGenerator);
  }
  addMacro(re, callback) {
    this.macros[re] = callback;
  }
  rewriteSelectors(options) {
    var _a, _b;
    let rewriteOnlyInSelectorsAreas = true;
    let matchSelectorsWithPrefixes = false;
    let content = "";
    if (typeof options === "string") {
      content = options;
    } else {
      content = options.content;
      rewriteOnlyInSelectorsAreas = (_a = options.rewriteOnlyInSelectorsAreas) != null ? _a : rewriteOnlyInSelectorsAreas;
      matchSelectorsWithPrefixes = (_b = options.matchSelectorsWithPrefixes) != null ? _b : matchSelectorsWithPrefixes;
    }
    if (!this.mangleSelectors) {
      return content;
    }
    if (content in this.rewrittenAreasCache) {
      return this.rewrittenAreasCache[content];
    }
    const originalContent = content;
    const selectorsListKeys = Object.keys(minifiedSelectorGenerator.processedSelectors).sort((a, b) => b.length - a.length);
    const rewriteContent = (contentToProcess, contentToReplace, contentToRewrite) => {
      const contentPlaceholders = {};
      const placeholderInserter = (matched) => {
        if (!(matched in contentPlaceholders)) {
          const placeholderKey = `_TEXT_${Object.keys(contentPlaceholders).length}_`;
          contentPlaceholders[matched] = placeholderKey;
        }
        return contentPlaceholders[matched];
      };
      contentToProcess = prepareStringForReplace(contentToProcess).replace(new RegExp(this.ignoredAreasRegExpString, "g"), (...args) => {
        const matchArguments = args.filter((value) => typeof value === "string");
        const fullMatch = matchArguments[0];
        const innerMatch = matchArguments[1];
        const replacement = typeof innerMatch === "undefined" || innerMatch.length === 0 ? fullMatch : fullMatch.replace(innerMatch, placeholderInserter(innerMatch));
        if (replacement !== fullMatch) {
          contentToReplace = contentToReplace.replaceAll(fullMatch, replacement);
          contentToRewrite = contentToRewrite.replaceAll(fullMatch, replacement);
        }
        return replacement;
      }).replace(
        new RegExp(this.contentOptionsRegExp.source, "g"),
        (matched) => placeholderInserter(matched)
      );
      contentToReplace = contentToReplace.replace(new RegExp(this.contentOptionsRegExp.source, "g"), "");
      contentToRewrite = contentToRewrite.replace(new RegExp(this.contentOptionsRegExp.source, "g"), "");
      const originalContentToRewrite = contentToRewrite;
      contentToRewrite = prepareStringForReplace(contentToRewrite);
      for (const selector of selectorsListKeys) {
        if (!contentToRewrite.includes(prepareStringForReplace(selector))) {
          continue;
        }
        const mangledSelector = minifiedSelectorGenerator.getMangledSelector(
          selector,
          this.mangledSelectorsPrefix
        );
        const selectorPrefix = matchSelectorsWithPrefixes ? minifiedSelectorGenerator.getSelectorPrefix(selector) : "";
        const selectorToReplace = escapeCssSelector(
          prepareStringForReplace(
            minifiedSelectorGenerator.getStringToMatch(selector, matchSelectorsWithPrefixes)
          )
        );
        const whiteSpacesRegExpPart = this.dev ? "" : "\\s*";
        const replacement = `${selectorPrefix}${mangledSelector}`;
        const selectorToReplaceRegExp = new RegExp(
          `${rewriteOnlyInSelectorsAreas ? this.macroRegExpStartPart : ""}(${whiteSpacesRegExpPart})(${selectorToReplace})(${whiteSpacesRegExpPart})`,
          "g"
        );
        let matched;
        while (matched = selectorToReplaceRegExp.exec(contentToRewrite)) {
          selectorToReplaceRegExp.lastIndex = 0;
          const [fullMatch, beforeSelector, selector2, afterSelector] = matched;
          const whiteSpaceBefore = /^(?:\s|\n)+/.test(beforeSelector) ? " " : "";
          const whiteSpaceAfter = /^(?:\s|\n)+/.test(afterSelector) ? " " : "";
          const processedFullMatch = fullMatch.replace(
            `${beforeSelector}${selector2}${afterSelector}`,
            `${whiteSpaceBefore}${replacement}${whiteSpaceAfter}`
          );
          contentToRewrite = contentToRewrite.replace(fullMatch, processedFullMatch);
        }
      }
      contentToProcess = contentToProcess.replace(
        prepareStringForReplace(contentToReplace),
        contentToReplace.replace(originalContentToRewrite, contentToRewrite)
      );
      for (const [originalContent2, contentPlaceholder] of Object.entries(contentPlaceholders)) {
        contentToProcess = contentToProcess.replace(new RegExp(contentPlaceholder, "g"), originalContent2);
      }
      contentToProcess = getStringOriginalStateAfterReplace(contentToProcess);
      return contentToProcess;
    };
    if (rewriteOnlyInSelectorsAreas) {
      for (const rewriteSelectorAreaRegExpString of this.selectorsAreas) {
        const matches = [...content.matchAll(new RegExp(rewriteSelectorAreaRegExpString.source, "g"))];
        for (const match of matches) {
          content = rewriteContent(content, match[0], match[1]);
        }
      }
    } else {
      content = rewriteContent(content, content, content);
    }
    this.rewrittenAreasCache[originalContent] = content;
    return content;
  }
  compile(content, compilationResult = null, matchOnlyInAreas = true) {
    let contentToProcess = "";
    content = content.replace(new RegExp(this.ignoredAreasRegExpString, "g"), (...args) => {
      const matchArguments = args.filter((value) => typeof value === "string");
      const fullMatch = matchArguments[0];
      const innerHtml = matchArguments[1];
      return typeof innerHtml === "undefined" || innerHtml.length === 0 ? fullMatch : fullMatch.replace(innerHtml, "");
    }).replace(/&amp;/ig, "&");
    content = content.replace(/\r\n|\r/ig, "\n");
    this.configure(this.processOptionsFromContent(this.getOptionsFromContent(content)));
    content = content.replace(new RegExp(this.contentOptionsRegExp.source, "g"), "");
    if (matchOnlyInAreas) {
      for (const selectorAreaRegExpString of this.selectorsAreas) {
        const regExp = new RegExp(selectorAreaRegExpString.source, "g");
        let selectorAreasMatches;
        while (selectorAreasMatches = regExp.exec(content)) {
          contentToProcess += " " + selectorAreasMatches[1];
        }
      }
    } else {
      contentToProcess = content;
    }
    contentToProcess = `${this.pregenerate} ${contentToProcess}`;
    this.pregenerate = "";
    if (this.matchCustomSelectors) {
      contentToProcess = contentToProcess.replace(
        /\[([^{}\s]+)\]{([^{}]+)}/g,
        (fullMatch, cssSelectors, stylifySelectors) => {
          this.generateMangledSelector(fullMatch);
          this.addCustomSelector(
            fullMatch,
            `${MacroMatch.replaceCharactersAliases(cssSelectors)}{${stylifySelectors.replace(/;/g, " ")}}`,
            false,
            "customMatchedInClass"
          );
          return "";
        }
      );
      contentToProcess = contentToProcess.replace(
        /(\S+):{([^{}]+)}/g,
        (fullMatch, screenAndPseudoClasses, stylifySelectors) => {
          this.generateMangledSelector(fullMatch);
          this.addCustomSelector(
            fullMatch,
            stylifySelectors.split(";").map((stylifySelector) => `${screenAndPseudoClasses}:${stylifySelector}`).join(" "),
            false,
            "utilitiesGroup"
          );
          return "";
        }
      );
    }
    this.processComponents(contentToProcess);
    const customSelectorsSelectorsMap = this.processCustomSelectors();
    compilationResult = compilationResult != null ? compilationResult : new CompilationResult();
    hooks.callHook("compiler:beforeMacrosProcessed", compilationResult);
    this.processMacros(contentToProcess, compilationResult);
    this.processMacros(Object.values(customSelectorsSelectorsMap).join(" "), compilationResult, false);
    hooks.callHook("compiler:afterMacrosProcessed", compilationResult);
    this.configureCompilationResult(compilationResult);
    compilationResult.bindCustomSelectorsToSelectors(customSelectorsSelectorsMap);
    return compilationResult;
  }
  getOptionsFromContent(content) {
    const contentOptions = {};
    const regExp = new RegExp(this.contentOptionsRegExp.source, "g");
    let optionMatch;
    while (optionMatch = regExp.exec(content)) {
      if (![typeof optionMatch[1], typeof optionMatch[2]].includes("string")) {
        continue;
      }
      const option = optionMatch[1];
      const optionValue = optionMatch[2];
      if (!(option in contentOptions)) {
        contentOptions[option] = [];
      }
      contentOptions[option].push(optionValue);
    }
    return contentOptions;
  }
  generateMangledSelector(selector, prefix = ".") {
    if (!this.mangleSelectors) {
      return selector;
    }
    minifiedSelectorGenerator.generateMangledSelector(selector, prefix);
    return minifiedSelectorGenerator.getMangledSelector(selector, this.mangledSelectorsPrefix);
  }
  configureCompilationResult(compilationResult) {
    const newLine = this.dev ? "\n" : "";
    const tab = this.dev ? "	" : "";
    const makeVariableString = (variable, value) => `${tab}--${variable}: ${String(value)};${newLine}`;
    let variablesCss = "";
    if (this.injectVariablesIntoCss) {
      let rootCss = "";
      let screensString = "";
      for (const [variableOrScreen, value] of Object.entries(this.variables)) {
        if (["string", "number"].includes(typeof value)) {
          rootCss += `${makeVariableString(variableOrScreen, String(value))}`;
          continue;
        }
        const newScreenStringPart = MacroMatch.replaceCharactersAliases(variableOrScreen, "space");
        if (!new RegExp(`(?:\\s|^)${newScreenStringPart}`).test(screensString)) {
          screensString += ` ${newScreenStringPart}`;
        }
      }
      if (rootCss) {
        variablesCss += `:root {${newLine}${rootCss}}${newLine}`;
      }
      const screensToSort = /* @__PURE__ */ new Map();
      for (const [key, screenData] of Object.entries(this.screens)) {
        const screenRegExp = new RegExp(`(?:\\s|^)\\b${key}`, "g");
        let screenMatches;
        while (screenMatches = screenRegExp.exec(screensString)) {
          if (screenMatches === null) {
            continue;
          }
          const matchedScreen = screenMatches[0].trim();
          const mediaData = typeof screenData === "function" ? screenData.call(this, new RegExpMatch(matchedScreen, screenMatches.slice(1))) : screenData;
          screensToSort.set(
            `@media ${mediaData}`,
            this.variables[matchedScreen]
          );
          screensString = screensString.replace(new RegExp(`(?:\\s|^)${matchedScreen}`), "");
        }
      }
      const sortedScreens = screensSorter.sortCssTreeMediaQueries(screensToSort);
      for (const screen of sortedScreens.keys()) {
        const screenVariables = sortedScreens.get(screen);
        let screenCss = "";
        for (const [variable, value] of Object.entries(screenVariables)) {
          screenCss += makeVariableString(variable, String(value));
        }
        variablesCss += `${screen} {${newLine}:root {${newLine}${screenCss}}${newLine}}${newLine}`;
      }
      screensString = screensString.trim();
      if (screensString.length) {
        for (let screen of screensString.split(" ")) {
          screen = MacroMatch.replaceCharactersAliases(screen, "space");
          variablesCss += `${screen} {${newLine}`;
          for (const [variable, value] of Object.entries(this.variables[screen])) {
            variablesCss += makeVariableString(variable, value);
          }
          variablesCss += `}${newLine}`;
        }
      }
    }
    let keyframesCss = "";
    for (const [keyframe, keyframeCode] of Object.entries(this.keyframes)) {
      keyframesCss += `@keyframes ${keyframe} {${keyframeCode.trimEnd()}${newLine}}${newLine}`;
    }
    compilationResult.configure({
      dev: this.dev,
      mangleSelectors: this.mangleSelectors,
      mangledSelectorsPrefix: this.mangledSelectorsPrefix,
      defaultCss: `${[variablesCss, keyframesCss].join(newLine).trim()}${newLine}`
    });
    hooks.callHook("compiler:compilationResultConfigured", compilationResult);
    return compilationResult;
  }
  processCustomSelectors() {
    var _a;
    const selectorsMap = {};
    for (const [selector, config] of Object.entries(this.customSelectors)) {
      const isComponent = config.type === "component";
      const isUtilitiesGroup = config.type === "utilitiesGroup";
      const isCustomSelectorMatchedInClass = config.type === "customMatchedInClass";
      const isClassSelector = isComponent || isUtilitiesGroup || isCustomSelectorMatchedInClass;
      const preparedEscapedSelector = this.mangleSelectors || config.type === "custom" ? selector : escapeCssSelector(selector, isComponent || isUtilitiesGroup || isCustomSelectorMatchedInClass);
      for (const customSelector of config.customSelectors) {
        const generatedCssEntries = customSelector.generateSelectors(
          `${isClassSelector ? "." : ""}${preparedEscapedSelector}`
        );
        let cssSelector;
        let stylifySelectors;
        for ([cssSelector, stylifySelectors] of Object.entries(generatedCssEntries)) {
          if (this.mangleSelectors && isComponent) {
            const preparedCssSelector = prepareStringForReplace(cssSelector);
            const preparedSelector = prepareStringForReplace(preparedEscapedSelector);
            cssSelector = preparedCssSelector.replace(
              new RegExp(`\\.(${preparedSelector}\\S*)`),
              (fullMatch, componentSelector) => {
                let clearedComponentName = "";
                const tokenizableComponentSelector = getStringOriginalStateAfterReplace(
                  componentSelector
                );
                tokenize(tokenizableComponentSelector, ({ token, previousToken }) => {
                  const isCorrectToken = /\w|-|\\|\$/.test(token);
                  if (!isCorrectToken && previousToken !== "\\") {
                    return true;
                  }
                  clearedComponentName += token;
                });
                return fullMatch.substring(1).replace(
                  prepareStringForReplace(clearedComponentName),
                  `.${this.generateMangledSelector(clearedComponentName)}`
                );
              }
            );
          }
          if (this.mangleSelectors) {
            cssSelector = this.rewriteSelectors({
              content: cssSelector,
              rewriteOnlyInSelectorsAreas: false,
              matchSelectorsWithPrefixes: true
            });
          }
          selectorsMap[cssSelector] = [(_a = selectorsMap[cssSelector]) != null ? _a : "", ...stylifySelectors.split(" ")].filter((item, index, self) => {
            return item.trim().length > 0 && self.indexOf(item) === index;
          }).join(" ").replace(/\s/g, " ").trim();
        }
      }
    }
    return selectorsMap;
  }
  processComponents(content) {
    for (const [componentName, config] of Object.entries(this.components)) {
      const regExp = new RegExp(`${this.macroRegExpStartPart}(${componentName}${this.macroRegExpEndPart})`, "g");
      let macroFullMatch;
      while (macroFullMatch = regExp.exec(content)) {
        const componentMatch = new RegExp(`${componentName}${this.macroRegExpEndPart}`).exec(macroFullMatch[1]);
        const componentSelector = componentMatch[0];
        for (const selectorsOrGenerator of config.selectorsOrGenerators) {
          const componentSelectors = typeof selectorsOrGenerator === "function" ? selectorsOrGenerator.call(
            this,
            new RegExpMatch(componentMatch[0], componentMatch.slice(1))
          ) : selectorsOrGenerator;
          this.generateMangledSelector(componentSelector);
          this.addCustomSelector(componentSelector, componentSelectors, false, "component");
        }
      }
    }
  }
  processMacros(content, compilationResult, utilitiesShouldBeGenerated = true) {
    if (!content.trim()) {
      return;
    }
    for (const regExpGenerator of this.macrosRegExpGenerators) {
      for (const macroKey in this.macros) {
        content = content.replace(new RegExp(`${this.macroRegExpStartPart}(${regExpGenerator(`${this.selectorsPrefix}${macroKey}`).source})`, "g"), (...args) => {
          const macroMatch = new MacroMatch(this, args.slice(0, args.length - 2));
          const existingCssRecord = compilationResult.getCssRecord(macroMatch);
          if (existingCssRecord) {
            if (utilitiesShouldBeGenerated && !existingCssRecord.utilityShouldBeGenerated) {
              compilationResult.configureCssRecord(existingCssRecord, {
                utilityShouldBeGenerated: utilitiesShouldBeGenerated
              });
            }
            return "";
          }
          const selectorProperties = this.macros[macroKey].call(this, macroMatch);
          for (const [property, propertyValue] of Object.entries(selectorProperties)) {
            selectorProperties[property] = this.processHelpers({ content: propertyValue });
          }
          for (const [property, value] of Object.entries(selectorProperties)) {
            selectorProperties[property] = this.replaceVariableString(value, `${property}:${value}`);
          }
          hooks.callHook("compiler:newMacroMatch", {
            match: macroMatch,
            utilityShouldBeGenerated: utilitiesShouldBeGenerated,
            selectorProperties,
            dev: this.dev,
            variables: this.variables,
            helpers: this.helpers
          });
          compilationResult.addCssRecord(macroMatch, selectorProperties, utilitiesShouldBeGenerated);
          return "";
        });
      }
    }
  }
  processHelpers({
    content,
    replaceByVariable,
    variablesScope
  }) {
    const helperArgumentPlaceholderStart = "_ARG";
    const helperArgumentPlaceholderEnd = "_";
    const helperArgumentRegExp = new RegExp(`${helperArgumentPlaceholderStart}(\\d+)${helperArgumentPlaceholderEnd}`);
    const cssVariableEnabled = this.cssVariablesEnabled && (replaceByVariable != null ? replaceByVariable : true);
    return content.replace(/(?:^|\s+)(\S+)\(([^)]+)\)/g, (fullHelperMatch, helperName, helperArguments) => {
      var _a;
      if (!(helperName in this.helpers)) {
        return fullHelperMatch;
      }
      const helperResultVariableName = `${helperName}${helperArguments}`.replace(/[^a-zA-Z0-9]/g, "-").replace(/[^a-zA-Z0-9]$/g, "");
      let matchedHelperResult = (_a = this.processedHelpers[helperResultVariableName]) != null ? _a : null;
      if (!matchedHelperResult) {
        const helperArgumentsPlaceholders = [];
        const helperArgumentsArray = helperArguments.replace(/'([^']+)'/g, (fullMatch, helperArgument) => {
          const helperPlaceholderKey = helperArgumentsPlaceholders.length;
          helperArgumentsPlaceholders.push(helperArgument);
          return `${helperArgumentPlaceholderStart}${helperPlaceholderKey}${helperArgumentPlaceholderEnd}`;
        }).split(",").map((helperArgument) => {
          helperArgument = helperArgument.replace(
            helperArgumentRegExp,
            (fullMatch, placeholderKeyMatch) => {
              return helperArgumentsPlaceholders[placeholderKeyMatch];
            }
          );
          if (helperArgument.startsWith("$")) {
            const variableName = helperArgument.slice(1);
            const { defined, isExternal } = this.isVariableDefined(
              variableName,
              fullHelperMatch,
              variablesScope
            );
            const definedVariables = variablesScope ? this.variables[variablesScope][variableName] : this.variables[variableName];
            const helperValue = defined && !isExternal ? definedVariables : void 0;
            if (!defined) {
              return `$${variableName}`;
            } else if (isExternal) {
              throw new Error(`Helpers cannot use external variables. Processing helper "${helperName}" and variable "${helperArgument}".`);
            } else if (["string", "number"].includes(typeof helperValue)) {
              helperArgument = String(helperValue);
            } else {
              throw new Error(`Screen "${helperArgument}" cannot be used as value in helper "${helperName}".`);
            }
          }
          return isNaN(Number(helperArgument)) ? helperArgument : parseFloat(helperArgument);
        });
        matchedHelperResult = this.helpers[helperName].call(this, ...helperArgumentsArray);
        if (cssVariableEnabled) {
          this.addVariables({ [helperResultVariableName]: matchedHelperResult });
        }
      }
      return fullHelperMatch.replace(
        `${helperName}(${helperArguments})`,
        cssVariableEnabled ? `var(--${helperResultVariableName})` : matchedHelperResult
      );
    });
  }
  replaceVariableString(string, contentContext) {
    return string.replace(
      this.variableRegExp,
      (match, substring) => {
        var _a;
        this.isVariableDefined(substring, contentContext);
        return this.cssVariablesEnabled ? `var(--${substring})` : (_a = this.variables[substring]) != null ? _a : match;
      }
    );
  }
  isVariableDefined(variable, contextContent, variablesScope = null) {
    let defined = false;
    let isExternal = false;
    const definedVariables = variablesScope ? this.variables[variablesScope] : this.variables;
    if (variable in definedVariables) {
      defined = true;
    } else {
      defined = this.externalVariables.includes(variable);
      if (!defined) {
        for (const externalVariableChecker of this.externalVariables) {
          if (typeof externalVariableChecker === "function") {
            const exists = externalVariableChecker.call(this, variable);
            defined = typeof exists === "boolean" ? exists : false;
          } else if (externalVariableChecker instanceof RegExp) {
            defined = externalVariableChecker.test(variable);
          }
          if (defined) {
            break;
          }
        }
      }
      isExternal = defined;
    }
    const errorMessage = `Stylify: Variable "${variable}" not found while processing "${contextContent}".`;
    if (!defined && this.undefinedVariableWarningLevel !== "silent") {
      if (this.dev || this.undefinedVariableWarningLevel === "warning") {
        console.warn(errorMessage);
      } else if (this.undefinedVariableWarningLevel === "error") {
        throw new Error(errorMessage);
      }
    }
    return {
      defined,
      isExternal
    };
  }
  processOptionsFromContent(options) {
    var _a;
    let contentOptions = {};
    for (const [option, optionValues] of Object.entries(options)) {
      for (const optionValue of optionValues) {
        try {
          if (option === "pregenerate") {
            contentOptions[option] += ` ${optionValue}`;
          } else if (option === "externalVariables") {
            contentOptions[option] = [
              ...(_a = contentOptions[option]) != null ? _a : [],
              ...optionValue.split(/\s/).filter((item) => item.trim().length)
            ];
          } else if (["components", "variables", "keyframes", "customSelectors", "screens"].includes(option)) {
            contentOptions[option] = __spreadValues(__spreadValues({}, contentOptions[option]), new Function(`return {${optionValue.trim()}}`)());
          } else {
            const hookData = hooks.callHook(`compiler:processContentOption:${option}`, {
              contentOptions,
              option,
              value: optionValue
            });
            contentOptions = hookData.contentOptions;
          }
        } catch (error) {
          if (this.dev) {
            console.error(
              `Error "${error}" occurred when processing "${option}" and its value "${optionValue}".`
            );
          }
        }
      }
    }
    return contentOptions;
  }
};

// packages/stylify/src/Compiler/CssRecord.ts
var CssRecord = class {
  constructor(config) {
    __publicField(this, "changed", false);
    __publicField(this, "sortedPropertiesKeys", []);
    __publicField(this, "utilityShouldBeGenerated", true);
    __publicField(this, "cache", null);
    __publicField(this, "selector", null);
    __publicField(this, "mangledSelector", null);
    __publicField(this, "screenId", null);
    __publicField(this, "scope", null);
    __publicField(this, "customSelectors", []);
    __publicField(this, "components", {});
    __publicField(this, "properties", {});
    __publicField(this, "pseudoClasses", []);
    this.configure(config);
  }
  configure(config = {}) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!Object.keys(config).length) {
      return;
    }
    this.mangledSelector = (_a = config.mangledSelector) != null ? _a : this.mangledSelector;
    this.screenId = (_b = config.screenId) != null ? _b : this.screenId;
    this.selector = (_d = (_c = config.selector) == null ? void 0 : _c.replace(/([^-_a-zA-Z\d])/g, "\\$1")) != null ? _d : this.selector;
    this.scope = (_e = config.scope) != null ? _e : null;
    this.utilityShouldBeGenerated = (_f = config.utilityShouldBeGenerated) != null ? _f : this.utilityShouldBeGenerated;
    if (/^\d/gm.test(this.selector[0])) {
      this.selector = "\\3" + this.selector;
    }
    this.addPseudoClasses((_g = config.pseudoClasses) != null ? _g : []);
    this.changed = true;
  }
  addProperties(properties) {
    for (const property in properties) {
      this.addProperty(property, properties[property]);
    }
  }
  addProperty(property, value) {
    if (property in this.properties) {
      return;
    }
    const addPropertyHookData = { [property]: value };
    const hookResult = hooks.callHook("cssRecord:addProperty", addPropertyHookData);
    this.changed = true;
    this.sortedPropertiesKeys = [];
    this.properties = __spreadValues(__spreadValues({}, this.properties), hookResult);
  }
  getSortedPropertiesKeys() {
    if (this.sortedPropertiesKeys.length === 0) {
      this.sortedPropertiesKeys = Object.keys(this.properties).map((item) => item.replace(/-(?:o|webkit|moz|ms)-/, "")).filter((value, index, array) => array.indexOf(value) === index).sort();
    }
    return this.sortedPropertiesKeys;
  }
  addPseudoClasses(pseudoClasses) {
    if (!Array.isArray(pseudoClasses)) {
      pseudoClasses = [pseudoClasses];
    }
    for (const pseudoClass of pseudoClasses) {
      if (this.pseudoClasses.includes(pseudoClass)) {
        continue;
      }
      this.changed = true;
      this.pseudoClasses.push(pseudoClass);
    }
  }
  addCustomSelector(selector) {
    if (this.customSelectors.includes(selector)) {
      return;
    }
    this.changed = true;
    this.customSelectors.push(selector);
  }
  addComponents(components) {
    for (const componentSelector in components) {
      this.addComponent(componentSelector, components[componentSelector]);
    }
  }
  addComponent(selector, selectorsChain = []) {
    selector = selector.replace(/([^-_a-zA-Z\d])/g, "\\$1");
    if (selector in this.components) {
      return;
    }
    this.changed = true;
    this.components[selector] = selectorsChain;
  }
  generateCss(config) {
    var _a;
    if (this.changed || !this.cache) {
      const newLine = config.minimize ? "" : "\n";
      const cssRecordSelector = config.mangleSelectors ? `${(_a = config.mangledSelectorsPrefix) != null ? _a : ""}${this.mangledSelector}` : this.selector;
      let customSelectors = [];
      let classSelectors = [];
      const componentsSelectors = [];
      for (const componentSelector in this.components) {
        const selectorsChain = this.components[componentSelector];
        if (selectorsChain.length === 1 && /^\s*$/gm.test(selectorsChain[0])) {
          selectorsChain.pop();
        }
        if (!selectorsChain.length) {
          componentsSelectors.push(componentSelector);
          continue;
        }
        for (let chainedSelectors of selectorsChain) {
          chainedSelectors = chainedSelectors.replace(/\s\s+/g, " ");
          componentsSelectors.push([...chainedSelectors.split(" "), componentSelector].join("."));
        }
      }
      if (this.pseudoClasses.length) {
        for (const pseudoClass of this.pseudoClasses) {
          const pseudoClassSuffix = `:${pseudoClass}`;
          customSelectors = this.customSelectors.map((selector) => {
            return `${selector}${pseudoClassSuffix}`;
          });
          classSelectors = [
            ...classSelectors,
            ...[this.utilityShouldBeGenerated ? `${cssRecordSelector}${pseudoClassSuffix}` : ""],
            ...componentsSelectors.map((selector) => {
              return `${selector}${pseudoClassSuffix}`;
            })
          ];
        }
      } else {
        customSelectors = this.customSelectors;
        classSelectors = [this.utilityShouldBeGenerated ? cssRecordSelector : "", ...componentsSelectors];
      }
      const removeEmptyItemsFromArray = (items) => items.filter((item) => item);
      const scopePart = this.scope ? this.scope : "";
      const selectors = [
        ...removeEmptyItemsFromArray(customSelectors).map((selector) => `${scopePart}${selector}`),
        ...removeEmptyItemsFromArray(classSelectors).map((selector) => `${scopePart}.${selector}`)
      ];
      const indentation = config.minimize ? "" : "	";
      const spacing = config.minimize ? "" : " ";
      this.cache = selectors.join("," + newLine) + "{" + newLine + Object.keys(this.properties).map((property) => `${indentation + property}:${spacing + this.properties[property]}`).join(";" + newLine) + newLine + "}" + newLine;
      this.changed = false;
    }
    hooks.callHook("cssRecord:cssGenerated", this);
    return this.cache;
  }
};

// packages/stylify/src/Compiler/RegExpMatch.ts
var RegExpMatch = class {
  constructor(fullMatch, captures) {
    __publicField(this, "fullMatch", null);
    __publicField(this, "captures", []);
    this.fullMatch = fullMatch.trim();
    this.captures = captures.filter((matchToFilter) => typeof matchToFilter !== "undefined");
  }
  getCapture(index, defaultValue = void 0) {
    var _a;
    return (_a = this.captures[index]) != null ? _a : defaultValue;
  }
};

// packages/stylify/src/Compiler/MacroMatch.ts
var _MacroMatch = class extends RegExpMatch {
  /**
   * Match
   * [0] => Full match with spaces
   * [1] => Full match trimmed
   * [2] => Pseudo classes and screens
   * [3] => Property
   * [4] => Value
   */
  constructor(compiler, match) {
    var _a, _b, _c, _d;
    super(match[1], match.slice(3));
    __publicField(this, "selector", null);
    __publicField(this, "screen", "_");
    __publicField(this, "pseudoClasses", null);
    const screenAndPseudoClassesMatch = (_b = (_a = match[2]) == null ? void 0 : _a.trim()) != null ? _b : null;
    this.selector = this.fullMatch;
    if (!screenAndPseudoClassesMatch) {
      return;
    }
    const screensAndPseudoClassesParts = [];
    const screensAndPseudoClassesTokens = screenAndPseudoClassesMatch.split("");
    const tokensLength = screensAndPseudoClassesTokens.length;
    let tokenQueue = "";
    let screenMatched = false;
    let pseudoClassesPart = screenAndPseudoClassesMatch;
    for (let i = 0; i <= tokensLength; i++) {
      const token = screensAndPseudoClassesTokens[i];
      const previousToken = (_c = screensAndPseudoClassesTokens[i - 1]) != null ? _c : "";
      const nextToken = (_d = screensAndPseudoClassesTokens[i + 1]) != null ? _d : "";
      const nextSequence = token + nextToken;
      const nextSequenceIsLogicalSeparator = _MacroMatch.logicalOperandsList.includes(nextSequence);
      const nextSequenceIsColonSeparator = token === "\\" && nextToken !== ":";
      const isLastToken = i === tokensLength;
      if (!(nextSequenceIsColonSeparator || nextSequenceIsLogicalSeparator || token === ":" && previousToken !== "\\" || isLastToken)) {
        tokenQueue += token;
        continue;
      }
      for (const key in compiler.screens) {
        const screenRegExp = new RegExp(`^${key}$`, "g");
        const screenMatches = screenRegExp.exec(tokenQueue);
        if (screenMatches === null) {
          continue;
        }
        let screenData = compiler.screens[key];
        if (typeof screenData === "function") {
          screenData = screenData.call(compiler, new RegExpMatch(screenMatches[0], screenMatches.slice(1)));
        }
        if (screenData) {
          pseudoClassesPart = pseudoClassesPart.substring(screenMatches[0].length);
          screensAndPseudoClassesParts.push(screenData);
          screenMatched = true;
          break;
        }
      }
      tokenQueue += token;
      if (nextSequenceIsLogicalSeparator) {
        pseudoClassesPart = pseudoClassesPart.substring(2);
        screensAndPseudoClassesParts.push(_MacroMatch.logicalOperandsReplacementMap[nextSequence]);
        i++;
        tokenQueue = "";
        continue;
      }
    }
    if (screenMatched) {
      this.screen = screensAndPseudoClassesParts.join("");
    }
    const pseudoClasses = pseudoClassesPart.replace(/^:/, "");
    if (pseudoClasses.trim().length) {
      this.pseudoClasses = pseudoClasses;
    }
  }
  static replaceCharactersAliases(content, alias = null) {
    const aliases = {
      space: [_MacroMatch.selectorSpaceAlias, " "],
      quote: [_MacroMatch.selectorQuoteAlias, "'"]
    };
    for (const [characterToReplace, replacement] of alias ? aliases[alias] : Object.values(aliases)) {
      content = content.replace(
        new RegExp(`(\\\\)?\\${characterToReplace}`, "g"),
        (fullMatch, escapeCharacter) => {
          return escapeCharacter ? fullMatch.replace(/\\/, "") : replacement;
        }
      );
    }
    return content;
  }
  getCapture(index, defaultValue = "") {
    const capture = super.getCapture(index);
    return capture === void 0 ? defaultValue : _MacroMatch.replaceCharactersAliases(capture);
  }
};
var MacroMatch = _MacroMatch;
__publicField(MacroMatch, "selectorSpaceAlias", "_");
__publicField(MacroMatch, "selectorQuoteAlias", "^");
__publicField(MacroMatch, "logicalOperandsReplacementMap", {
  "&&": " and ",
  "||": ", "
});
__publicField(MacroMatch, "logicalOperandsList", Object.keys(_MacroMatch.logicalOperandsReplacementMap));

// packages/stylify/src/Compiler/CompilationResult.ts
var CompilationResult = class {
  constructor(config = {}) {
    __publicField(this, "id");
    __publicField(this, "screensList", /* @__PURE__ */ new Map());
    __publicField(this, "selectorsList", {});
    __publicField(this, "screensListSorted", false);
    __publicField(this, "reconfigurable", true);
    __publicField(this, "changed", false);
    __publicField(this, "mangleSelectors", false);
    __publicField(this, "mangledSelectorsPrefix", "");
    __publicField(this, "dev", false);
    __publicField(this, "screensSortingFunction", null);
    __publicField(this, "defaultCss", "");
    this.id = createUId();
    this.addScreen("_");
    this.configure(config);
  }
  configure(config = {}) {
    var _a, _b, _c, _d, _e;
    if (!Object.keys(config).length) {
      return;
    }
    this.dev = (_a = config.dev) != null ? _a : this.dev;
    this.reconfigurable = (_b = config.reconfigurable) != null ? _b : this.reconfigurable;
    this.mangleSelectors = (_c = config.mangleSelectors) != null ? _c : this.mangleSelectors;
    this.mangledSelectorsPrefix = (_d = config.mangledSelectorsPrefix) != null ? _d : this.mangledSelectorsPrefix;
    this.defaultCss = config.defaultCss || this.defaultCss;
    this.screensSortingFunction = (_e = config.screensSortingFunction) != null ? _e : screensSorter.sortCssTreeMediaQueries;
    this.addScreens(config.screensList || {});
  }
  getScreenById(searchId) {
    let searchedScreen = null;
    [...this.screensList].find(([screen, screenId]) => {
      const found = screenId === searchId;
      if (found) {
        searchedScreen = screen;
      }
      return found;
    });
    return searchedScreen;
  }
  addScreens(screens) {
    for (const screen in screens) {
      this.addScreen(screen, screens[screen]);
    }
  }
  addScreen(screen, screenId = this.screensList.size) {
    if (this.screensList.has(screen)) {
      return;
    }
    this.screensList.set(screen, screenId);
    this.screensListSorted = false;
  }
  generateCss() {
    let css = this.defaultCss;
    const newLine = this.dev ? "\n" : "";
    const cssTree = {};
    const sortedSelectors = Object.keys(this.selectorsList).sort((a, b) => {
      const cssRecordA = this.selectorsList[a];
      const cssRecordB = this.selectorsList[b];
      let propertiesComparisonArray = [];
      let propertyAForComparison = null;
      const cssRecordAProps = cssRecordA.getSortedPropertiesKeys();
      const cssRecordBProps = cssRecordB.getSortedPropertiesKeys();
      for (let i = 0; i < cssRecordAProps.length; i++) {
        const propertyOfA = cssRecordAProps[i];
        const propertyOfB = cssRecordBProps[i];
        if (propertyOfB === void 0 || propertyOfA === propertyOfB) {
          continue;
        }
        propertyAForComparison = propertyOfA;
        propertiesComparisonArray = [propertyOfA, propertyOfB];
        break;
      }
      if (propertiesComparisonArray.length === 0) {
        return 0;
      }
      const firstItem = propertiesComparisonArray.sort()[0];
      return firstItem === propertyAForComparison ? -1 : 1;
    });
    for (const selector of sortedSelectors) {
      const cssRecord = this.selectorsList[selector];
      const screen = this.getScreenById(cssRecord.screenId);
      if (!(screen in cssTree)) {
        cssTree[screen] = "";
      }
      cssTree[screen] += this.selectorsList[selector].generateCss({
        minimize: !this.dev,
        mangleSelectors: this.mangleSelectors,
        mangledSelectorsPrefix: this.mangledSelectorsPrefix
      });
    }
    if (!this.screensListSorted) {
      this.screensList = this.screensSortingFunction(this.screensList);
    }
    for (const [screen] of this.screensList) {
      const screenCss = cssTree[screen] || null;
      if (!screenCss) {
        continue;
      }
      css += screen === "_" ? screenCss : `${newLine}@media ${screen} {${newLine}${screenCss}}${newLine}`;
    }
    this.changed = false;
    return css.trim();
  }
  getCssRecord(macroMatch) {
    var _a;
    return (_a = this.selectorsList[macroMatch.fullMatch]) != null ? _a : null;
  }
  configureCssRecord(cssRecord, config) {
    cssRecord.configure(config);
    this.changed = true;
  }
  addCssRecord(macroMatch, selectorProperties, utilityShouldBeGenerated = true) {
    if (macroMatch.fullMatch in this.selectorsList) {
      return;
    }
    const selector = macroMatch.selector;
    const screen = macroMatch.screen;
    if (!this.screensList.has(screen)) {
      this.addScreen(screen);
    }
    const newCssRecord = new CssRecord({
      screenId: this.screensList.get(screen),
      selector,
      mangledSelector: `${this.mangledSelectorsPrefix}${minifiedSelectorGenerator.generateMangledSelector(selector)}`,
      pseudoClasses: macroMatch.pseudoClasses ? [macroMatch.pseudoClasses] : [],
      utilityShouldBeGenerated
    });
    hooks.callHook("compilationResult:configureCssRecord", { compilationResult: this, cssRecord: newCssRecord });
    newCssRecord.addProperties(selectorProperties);
    this.selectorsList[selector] = newCssRecord;
    this.changed = true;
  }
  bindCustomSelectorsToSelectors(customSelectorsSelectorsMap) {
    for (const [customSelector, dependencySelectors] of Object.entries(customSelectorsSelectorsMap)) {
      for (const dependencySelector of dependencySelectors.split(" ").filter((item) => item.trim() !== "")) {
        if (!(dependencySelector in this.selectorsList)) {
          throw new Error(`Selector "${dependencySelector}" for custom selector "${customSelector}" was not matched and therefore not added.`);
        }
        this.selectorsList[dependencySelector].addCustomSelector(customSelector);
      }
    }
  }
};

// packages/stylify/src/Compiler/MinifiedSelectorGenerator.ts
var MinifiedSelectorGenerator = class {
  constructor() {
    __publicField(this, "letters", "abcdefghijklmnopqrstuvwxyz");
    __publicField(this, "lettersLength", this.letters.length);
    __publicField(this, "lastLetterIndex", this.lettersLength - 1);
    __publicField(this, "processedSelectors", {});
  }
  getSelectorPrefix(selector) {
    var _a;
    return (_a = this.processedSelectors[selector].prefix) != null ? _a : "";
  }
  getStringToMatch(selector, addPrefix = false) {
    var _a;
    return addPrefix ? `${(_a = this.processedSelectors[selector].prefix) != null ? _a : ""}${selector}` : selector;
  }
  generateMangledSelector(selector, prefix = ".") {
    if (!(selector in this.processedSelectors)) {
      this.processedSelectors[selector] = {
        mangledSelector: this.divideLengthAndGetLetter(
          Object.keys(this.processedSelectors).length
        ),
        prefix
      };
    }
    return this.processedSelectors[selector].mangledSelector;
  }
  getMangledSelector(selector, prefix = "") {
    var _a, _b;
    let mangledSelector = (_b = (_a = this.processedSelectors[selector]) == null ? void 0 : _a.mangledSelector) != null ? _b : null;
    if (mangledSelector && prefix.length) {
      mangledSelector = prefix + mangledSelector;
    }
    return mangledSelector;
  }
  divideLengthAndGetLetter(length) {
    let shortSelector = "";
    if (length > this.lastLetterIndex) {
      const flooredModulus = Math.floor(length / this.lettersLength);
      const modulusLetterId = flooredModulus - 1;
      const difference = length - this.lettersLength * flooredModulus;
      shortSelector = this.letters[difference];
      shortSelector = modulusLetterId > this.lastLetterIndex ? this.divideLengthAndGetLetter(modulusLetterId) + shortSelector : this.letters[modulusLetterId] + shortSelector;
    } else {
      shortSelector = this.letters[length];
    }
    return shortSelector;
  }
};
var minifiedSelectorGenerator = new MinifiedSelectorGenerator();

// packages/stylify/src/Compiler/ScreensSorter.ts
var ScreensSorter = class {
  constructor() {
    __publicField(this, "sortCssTreeMediaQueries", (screensList) => {
      const sortedScreens = /* @__PURE__ */ new Map();
      if (screensList.has("_")) {
        sortedScreens.set("_", screensList.get("_"));
        screensList.delete("_");
      }
      const lightModeScreensListKeys = [];
      const darkModeScreensListKeys = [];
      const printScreensListKeys = [];
      const screensListKeysArray = [...screensList.keys()].filter((screen) => {
        if (screen.includes("(prefers-color-scheme: dark)")) {
          darkModeScreensListKeys.push(screen);
          return false;
        } else if (screen.includes("(prefers-color-scheme: light)")) {
          lightModeScreensListKeys.push(screen);
          return false;
        } else if (screen.includes("print")) {
          printScreensListKeys.push(screen);
          return false;
        }
        return true;
      });
      const convertUnitToPxSize = (unit) => {
        const unitMatch = /(\d*\.?\d+)(ch|em|ex|px|rem)/.exec(unit);
        if (!unitMatch) {
          return null;
        }
        const unitSize = unitMatch[1];
        const unitType = unitMatch[2];
        let newUnitSize = parseFloat(unitSize);
        if (unitType === "ch") {
          newUnitSize = parseFloat(unitSize) * 8.8984375;
        } else if (["em", "rem"].includes(unitType)) {
          newUnitSize = parseFloat(unitSize) * 16;
        } else if (unitType === "ex") {
          newUnitSize = parseFloat(unitSize) * 8.296875;
        }
        return newUnitSize;
      };
      const getMediaQueryValue = (mediaQuery) => {
        const regExp = new RegExp("[\\w-]+: ?\\d*.?\\d+(?:ch|em|ex|px|rem)");
        const match = regExp.exec(mediaQuery);
        return match ? convertUnitToPxSize(match[0]) : Number.MAX_VALUE;
      };
      const separateAndSort = (cssTreeKeys, mediaQueryType, desc = false) => {
        const cssTreeKeysToReturn = [];
        const sortedKeys = cssTreeKeys.filter((mediaQuery) => {
          const regExp = new RegExp(`${mediaQueryType}: ?\\d*.?\\d+(?:ch|em|ex|px|rem)`);
          if (!regExp.exec(mediaQuery)) {
            cssTreeKeysToReturn.push(mediaQuery);
            return false;
          }
          return true;
        }).sort((next, previous) => {
          const result = getMediaQueryValue(next) > getMediaQueryValue(previous);
          if (desc) {
            return result ? -1 : 0;
          }
          return result ? 0 : -1;
        });
        mapSortedKeys(sortedKeys);
        return cssTreeKeysToReturn;
      };
      const mapSortedKeys = (sortedKeys) => {
        for (const sortedKey of sortedKeys) {
          sortedScreens.set(sortedKey, screensList.get(sortedKey));
          screensList.delete(sortedKey);
        }
      };
      const sortScreensListKeys = (screensListKeys) => {
        screensListKeys = separateAndSort(screensListKeys, "min-width");
        screensListKeys = separateAndSort(screensListKeys, "min-height");
        screensListKeys = separateAndSort(screensListKeys, "max-width", true);
        screensListKeys = separateAndSort(screensListKeys, "max-height", true);
        screensListKeys = separateAndSort(screensListKeys, "min-device-width");
        screensListKeys = separateAndSort(screensListKeys, "min-device-height");
        screensListKeys = separateAndSort(screensListKeys, "max-device-width", true);
        screensListKeys = separateAndSort(screensListKeys, "max-device-height", true);
        return screensListKeys;
      };
      mapSortedKeys([
        ...sortScreensListKeys(screensListKeysArray),
        ...sortScreensListKeys(lightModeScreensListKeys),
        ...sortScreensListKeys(darkModeScreensListKeys),
        ...sortScreensListKeys(printScreensListKeys)
      ]);
      return sortedScreens;
    });
  }
};
var screensSorter = new ScreensSorter();

// packages/stylify/src/Compiler/defaultPreset.ts
var rangeScreen = (screen) => {
  const ranges = screen.replace("rng", "").split("-");
  return `${minWidthScreen(ranges[0])} and ${maxWidthScreen(ranges[1])}`;
};
var minWidthScreen = (screen) => `(min-width: ${screen.replace("minw", "")})`;
var maxWidthScreen = (screen) => `(max-width: ${screen.replace("maxw", "")})`;
var minHeightScreen = (screen) => `(min-height: ${screen.replace("minh", "")})`;
var maxHeightScreen = (screen) => `(max-height: ${screen.replace("maxh", "")})`;
var orientationScreen = (screen) => `(orientation: ${screen})`;
var defaultPreset = {
  ignoredAreas: [
    /stylify-ignore([\s\S]*?)\/stylify-ignore/,
    /<code[\s]*?>([\s\S]*?)<\/code>/,
    /<head[\s]*?>([\s\S]*?)<\/head>/,
    /<pre[\s]*?>([\s\S]*?)<\/pre>/,
    /<script[\s]*?>([\s\S]*?)<\/script>/,
    /<style[\s]*?>([\s\S]*?)<\/style>/
  ],
  selectorsAreas: [
    // HTML
    /(?:^|\s+)class="([^"]+)"/,
    /(?:^|\s+)class='([^']+)'/,
    // React
    /(?:^|\s+)className="([^"]+)"/,
    /(?:^|\s+)className='([^']+)'/,
    /(?:^|\s+)className=\{((?:.|\n)+)\}/,
    // JSX compiled
    /(?:^|\s+)className:\s*`((?:.|\n)+)`/,
    /(?:^|\s+)className:\s*"([^"]+)"/,
    /(?:^|\s+)className:\s*'([^']+)"/,
    // Vue and alpinejs
    /(?:^|\s+)(?:v-bind|x-bind)?:class="([^"]+)"/,
    /(?:^|\s+)(?:v-bind|x-bind)?:class='([^']+)'/,
    // Lit
    /(?:^|\s+)class=\$\{((?:.|\n)+)\}/,
    // Angular
    /(?:^|\s+)\[(?:ngClass|className)\]="([^"]+)/,
    /(?:^|\s+)\[(?:ngClass|className)\]='([^']+)/,
    // Nette
    /(?:^|\s+)n:class="([^"]+)"/,
    /(?:^|\s+)n:class='([^']+)'/,
    // Twig form widgets
    /'class':\s*'([^']+)'/,
    /'class':\s*"([^"]+)"/,
    /"class":\s*"([^"]+)"/,
    /"class":\s*'([^']+)'/,
    // Escaped default areas
    /(?:^|\s+)class=\\"([^"]+)\\"/,
    /(?:^|\s+)class=\\'([^']+)\\'/,
    // Astro
    /(?:^|\s+)class=\{`([^`]+)`\}/,
    /(?:^|\s+)class=\{((?:.|\n)+)\}/,
    /(?:^|\s+)class:list=\{\s*\[((?:.|\n)+)\]\s*\}/,
    // Svelte
    /(?:^|\s+)class:(\S+)=[{"']/,
    // Objects
    /(?:^|\s+)"class":\s*`([^`]+)`/
  ],
  screens: {
    tosm: maxWidthScreen("639px"),
    sm: minWidthScreen("640px"),
    tomd: maxWidthScreen("767px"),
    md: minWidthScreen("768px"),
    tolg: maxWidthScreen("1023px"),
    lg: minWidthScreen("1024px"),
    toxl: maxWidthScreen("1279px"),
    xl: minWidthScreen("1280px"),
    to2xl: maxWidthScreen("1535px"),
    "2xl": minWidthScreen("1536px"),
    to3xl: maxWidthScreen("1919px"),
    "3xl": minWidthScreen("1920px"),
    "minw\\w+": (match) => minWidthScreen(match.fullMatch),
    "maxw\\w+": (match) => maxWidthScreen(match.fullMatch),
    "minh\\w+": (match) => minHeightScreen(match.fullMatch),
    "maxh\\w+": (match) => maxHeightScreen(match.fullMatch),
    "rng[\\d\\w]+-[\\d\\w]+": (match) => rangeScreen(match.fullMatch),
    screen: "screen",
    print: "print",
    onlyScreen: "only screen",
    portrait: orientationScreen("portrait"),
    landscape: orientationScreen("landscape"),
    dark: "(prefers-color-scheme: dark)",
    light: "(prefers-color-scheme: light)"
  },
  macros: {
    // eslint-disable-next-line max-len
    "(accent-color|additive-symbols|align-(?:content|items|self)|alignment-baseline|all|alt|animation(?:-(?:composition|delay|direction|duration|fill-mode|iteration-count|name|play-state|timeline|timing-function))?|app-region|appearance|apple-(?:color-filter|pay-(?:button-(?:style|type))|trailing-word)|ascent-override|aspect-ratio|backdrop-filter|backface-visibility|background(?:-(?:attachment|blend-mode|clip|color|image|origin|position(?:-(?:x|y))?|repeat(?:-(?:x|y))?|size))?|base-palette|baseline-(?:shift|source)|block-size|border(?:-(?:block(?:-(?:color|end(?:-(?:color|style|width))?|start(?:-(?:color|style|width))?|style|width))?|bottom(?:-(?:color|left-radius|right-radius|style|width))?|collapse|color|end-(?:end-radius|start-radius)|image(?:-(?:outset|repeat|slice|source|width))?|inline(?:-(?:color|end(?:-(?:color|style|width))?|start(?:-(?:color|style|width))?|style|width))?|left(?:-(?:color|style|width))?|radius|right(?:-(?:color|style|width))?|spacing|start-(?:end-radius|start-radius)|style|top(?:-(?:color|left-radius|right-radius|style|width))?|width))?|bottom|box-(?:decoration-break|shadow|sizing)|break-(?:after|before|inside)|buffered-rendering|caption-side|caret-color|clear|clip(?:-(?:path|rule))?|color(?:-(?:adjust|interpolation(?:-filters)?|rendering|scheme))?|column-(?:count|fill|gap|rule(?:-(?:color|style|width))?|span|width)|columns|contain(?:-(?:intrinsic-(?:block-size|height|inline-size|size|width)))?|container(?:-(?:name|type))?|content(?:-visibility)?|counter-(?:increment|reset|set)|cursor|cx|cy|d|descent-override|direction|display|dominant-baseline|empty-cells|fallback|fill(?:-(?:opacity|rule))?|filter|flex(?:-(?:basis|direction|flow|grow|shrink|wrap))?|float|flood-(?:color|opacity)|font(?:-(?:display|family|feature-settings|kerning|language-override|optical-sizing|palette|size(?:-adjust)?|stretch|style|synthesis(?:-(?:small-caps|style|weight))?|variant(?:-(?:alternates|caps|east-asian|ligatures|numeric|position))?|variation-settings|weight))?|forced-(?:color-adjust)|gap|glyph-(?:orientation-(?:horizontal|vertical))|grid(?:-(?:area|auto-(?:columns|flow|rows)|column(?:-(?:end|gap|start))?|gap|row(?:-(?:end|gap|start))?|template(?:-(?:areas|columns|rows))?))?|hanging-punctuation|height|hyphenate-(?:character|limit-chars)|hyphens|image-(?:orientation|rendering)|ime-mode|inherits|initial-(?:letter|value)|inline-size|inset(?:-(?:block(?:-(?:end|start))?|inline(?:-(?:end|start))?))?|isolation|justify-(?:content|items|self)|kerning|left|letter-spacing|lighting-color|line-(?:break|gap-override|height(?:-step)?)|list-(?:style(?:-(?:image|position|type))?)|margin(?:-(?:block(?:-(?:end|start))?|bottom|inline(?:-(?:end|start))?|left|right|top))?|marker(?:-(?:end|mid|start))?|mask(?:-(?:clip|composite|image|mode|origin|position(?:-(?:x|y))?|repeat|size|type))?|math-(?:depth|shift|style)|max-(?:block-size|height|inline-size|width|zoom)|min-(?:block-size|height|inline-size|width|zoom)|mix-(?:blend-mode)|moz-(?:appearance|box-(?:align|direction|flex|ordinal-group|orient|pack)|float-edge|force-(?:broken-(?:image-icon))|image-region|orient|outline-(?:radius-(?:bottomleft|bottomright|topleft|topright))|stack-sizing|tab-size|text-(?:size-adjust)|user-(?:focus|input|modify|select)|window-dragging)|negative|object-(?:fit|position|view-box)|offset(?:-(?:anchor|distance|path|position|rotate))?|opacity|order|orientation|orphans|outline(?:-(?:color|offset|style|width))?|overflow(?:-(?:anchor|clip-margin|wrap|x|y))?|override-colors|overscroll-(?:behavior(?:-(?:block|inline|x|y))?)|pad|padding(?:-(?:block(?:-(?:end|start))?|bottom|inline(?:-(?:end|start))?|left|right|top))?|page(?:-(?:break-(?:after|before|inside)|orientation))?|paint-order|perspective(?:-(?:origin(?:-(?:x|y))?))?|place-(?:content|items|self)|pointer-events|position|prefix|quotes|r|range|resize|right|rotate|row-gap|ruby-(?:align|position)|rx|ry|scale|scroll-(?:behavior|margin(?:-(?:block(?:-(?:end|start))?|bottom|inline(?:-(?:end|start))?|left|right|top))?|padding(?:-(?:block(?:-(?:end|start))?|bottom|inline(?:-(?:end|start))?|left|right|top))?|snap-(?:align|margin-(?:bottom|left|right|top)|stop|type))|scrollbar-(?:color|gutter|width)|shape-(?:image-threshold|margin|outside|rendering)|size(?:-adjust)?|speak(?:-as)?|src|stop-(?:color|opacity)|stroke(?:-(?:color|dasharray|dashoffset|linecap|linejoin|miterlimit|opacity|width))?|suffix|symbols|syntax|system|tab-size|table-layout|text-(?:align(?:-last)?|anchor|combine-upright|decoration(?:-(?:color|line|skip(?:-ink)?|style|thickness))?|emphasis(?:-(?:color|position|style))?|indent|justify|orientation|overflow|rendering|shadow|size-adjust|transform|underline-(?:offset|position)|wrap)|top|touch-action|transform(?:-(?:box|origin(?:-(?:x|y|z))?|style))?|transition(?:-(?:delay|duration|property|timing-function))?|translate|unicode-(?:bidi|range)|user-(?:select|zoom)|vector-effect|vertical-align|view-(?:transition-name)|visibility|webkit-(?:align-(?:content|items|self)|animation(?:-(?:delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function))?|app-region|appearance|aspect-ratio|backdrop-filter|backface-visibility|background-(?:clip|composite|origin|size)|border-(?:after(?:-(?:color|style|width))?|before(?:-(?:color|style|width))?|bottom-(?:left-radius|right-radius)|end(?:-(?:color|style|width))?|fit|horizontal-spacing|image|radius|start(?:-(?:color|style|width))?|top-(?:left-radius|right-radius)|vertical-spacing)|box-(?:align|decoration-break|direction|flex(?:-group)?|lines|ordinal-group|orient|pack|reflect|shadow|sizing)|clip-path|column-(?:axis|break-(?:after|before|inside)|count|gap|progression|rule(?:-(?:color|style|width))?|span|width)|columns|cursor-visibility|filter|flex(?:-(?:basis|direction|flow|grow|shrink|wrap))?|font-(?:feature-settings|kerning|smoothing)|highlight|hyphenate-(?:character|limit-(?:after|before|lines))|hyphens|initial-letter|justify-content|line-(?:align|box-contain|break|clamp|grid|snap)|locale|logical-(?:height|width)|margin-(?:after(?:-collapse)?|before(?:-collapse)?|bottom-collapse|end|start|top-collapse)|mask(?:-(?:box-(?:image(?:-(?:outset|repeat|slice|source|width))?)|clip|composite|image|origin|position(?:-(?:x|y))?|repeat(?:-(?:x|y))?|size|source-type))?|max-(?:logical-(?:height|width))|min-(?:logical-(?:height|width))|nbsp-mode|opacity|order|padding-(?:after|before|end|start)|perspective(?:-(?:origin(?:-(?:x|y))?))?|print-(?:color-adjust)|rtl-ordering|ruby-position|shape-(?:image-threshold|margin|outside)|tap-(?:highlight-color)|text-(?:combine|decorations-(?:in-effect)|emphasis(?:-(?:color|position|style))?|fill-color|orientation|security|size-adjust|stroke(?:-(?:color|width))?|zoom)|transform(?:-(?:origin(?:-(?:x|y|z))?|style))?|transition(?:-(?:delay|duration|property|timing-function))?|user-(?:drag|modify|select)|writing-mode)|white-(?:space(?:-collapse)?)|widows|width|will-change|word-(?:break|spacing|wrap)|writing-mode|x|y|z-index|zoom):(\\S+?)": (match) => {
      const propertyName = match.getCapture(0);
      return { [`${/^(?:apple|webkit|moz)/.test(propertyName) ? "-" : ""}${propertyName}`]: match.getCapture(1) };
    }
  },
  helpers: {
    darken: (color, amount) => lightenDarkenColor(color, -amount),
    lighten: (color, amount) => lightenDarkenColor(color, amount),
    colorToRgb: (color, alpha = null) => {
      const { r, g, b } = parseColor(color);
      const rgb = `${r},${g},${b}`;
      return alpha ? `rgba(${rgb},${alpha})` : `rgb(${rgb})`;
    }
  }
};

// packages/stylify/src/Compiler/CustomSelector.ts
var CustomSelector = class {
  constructor(content) {
    __publicField(this, "placeholderCharacter", "&");
    __publicField(this, "placeholderCharacterRegExp", new RegExp(this.placeholderCharacter, "g"));
    __publicField(this, "generatedSelectors", {});
    __publicField(this, "tree");
    this.parseTree(content);
  }
  generateSelectors(rootSelector = "") {
    if (rootSelector in this.generatedSelectors) {
      return this.generatedSelectors[rootSelector];
    }
    const selectors = {};
    const replaceRootPlaceholder = (selector, rootSelector2) => selector.replace(
      this.placeholderCharacterRegExp,
      rootSelector2
    );
    const processTree = (selectorToAdd, tree) => {
      var _a;
      for (const [key, selectorsOrChildren] of Object.entries(tree)) {
        if (key === "selectors") {
          if (!selectorsOrChildren.length) {
            continue;
          }
          selectors[selectorToAdd] = [(_a = selectors[selectorToAdd]) != null ? _a : "", selectorsOrChildren].join(" ");
          continue;
        }
        for (const [selector, childTree] of Object.entries(tree.children)) {
          for (const selectorSplitPart of selector.split(",")) {
            let actualTreeSelector = selectorToAdd;
            const selectorIncludesPlaceholder = selectorSplitPart.includes("&");
            if (selectorIncludesPlaceholder) {
              actualTreeSelector = `${selector.startsWith(this.placeholderCharacter) ? " " : ""}${replaceRootPlaceholder(selectorSplitPart, actualTreeSelector)}`;
            } else {
              actualTreeSelector += ` ${replaceRootPlaceholder(
                selectorIncludesPlaceholder ? selectorSplitPart.substring(1) : selectorSplitPart,
                actualTreeSelector
              )}`;
            }
            processTree(actualTreeSelector.trim(), childTree);
          }
        }
      }
    };
    processTree(rootSelector, this.tree);
    this.generatedSelectors[rootSelector] = selectors;
    return selectors;
  }
  parseTree(content) {
    const createTree = () => ({
      selectors: "",
      children: {}
    });
    let contentIterator = 0;
    const contentlength = content.length;
    const parseContent = (content2, actualTree) => {
      let tokenQueue = "";
      while (contentIterator < contentlength) {
        const character = content2[contentIterator];
        contentIterator++;
        if (character === "{") {
          const nestedTreeSelector = tokenQueue.match(/(?:\n|^)([^\n]+)$/);
          if (!nestedTreeSelector) {
            throw new Error(`Selector levels cannot be created without selector. Processing "${content2}".`);
          }
          actualTree.selectors += tokenQueue.replace(nestedTreeSelector[0], "");
          tokenQueue = "";
          actualTree.children[nestedTreeSelector[1].trim()] = parseContent(content2, createTree());
        } else if (character === "}") {
          actualTree.selectors += tokenQueue;
          break;
        } else {
          tokenQueue += character;
          if (contentIterator === contentlength) {
            actualTree.selectors += tokenQueue;
            tokenQueue = "";
            break;
          }
        }
      }
      return actualTree;
    };
    this.tree = parseContent(content, createTree());
  }
};

// packages/stylify/src/Runtime.ts
var _Runtime = class {
  constructor(config = {}) {
    __publicField(this, "dev", false);
    __publicField(this, "compiler");
    __publicField(this, "hooks", hooks);
    __publicField(this, "compilationResult");
    __publicField(this, "initialPaintCompleted", false);
    __publicField(this, "mutationObserverInitialized", false);
    __publicField(this, "repaintTimeout", 100);
    if (typeof document === "undefined") {
      return;
    }
    this.configure(config);
    hooks.callHook("stylify:ready", this);
    if (["complete", "loaded", "interactive"].includes(document.readyState)) {
      this.init();
      return;
    }
    document.addEventListener("DOMContentLoaded", () => this.init());
  }
  configure(config) {
    var _a, _b, _c, _d, _e;
    const compilerConfig = (_a = config.compiler) != null ? _a : {};
    this.dev = (_b = config.dev) != null ? _b : this.dev;
    this.repaintTimeout = (_c = config.repaintTimeout) != null ? _c : this.repaintTimeout;
    compilerConfig.dev = (_d = compilerConfig.dev) != null ? _d : this.dev;
    compilerConfig.ignoredAreas = [
      ...(_e = compilerConfig.ignoredAreas) != null ? _e : [],
      ...[/stylify-runtime-ignore([\s\S]*?)\/stylify-runtime-ignore/]
    ];
    try {
      if (!this.compiler) {
        this.compiler = new Compiler();
      }
      this.compiler.configure(compilerConfig);
    } catch (error) {
      console.error(error);
      return;
    }
    hooks.callHook("stylify:configured", {
      config
    });
    if (this.initialPaintCompleted) {
      this.compilationResult = null;
      this.updateCss(document.documentElement.outerHTML);
    }
  }
  init() {
    if (!this.initialPaintCompleted) {
      const content = document.documentElement.outerHTML;
      this.updateCss(content, () => {
        this.initialPaintCompleted = true;
      });
    }
    if (!this.mutationObserverInitialized) {
      this.initMutationObserver();
    }
  }
  updateCss(content, callback = null) {
    try {
      this.compilationResult = this.compiler.compile(content, this.compilationResult);
    } catch (error) {
      console.error(error);
      return;
    }
    if (!this.compilationResult.changed && this.initialPaintCompleted) {
      return;
    }
    const css = this.compilationResult.generateCss();
    this.injectCss(css);
    if (callback) {
      callback({
        css,
        compilationResult: this.compilationResult,
        content
      });
    }
    hooks.callHook("stylify:repainted", {
      css,
      compilationResult: this.compilationResult,
      content
    });
    return css;
  }
  initMutationObserver() {
    this.mutationObserverInitialized = true;
    const targetNode = document.documentElement;
    const config = { attributeFilter: ["class"], childList: true, subtree: true };
    let compilerContentQueue = "";
    let updateTimeout;
    const ignoreSelector = `.${_Runtime.ignoreClass}`;
    const observer = new MutationObserver((mutationsList) => {
      mutationsList.forEach((mutation) => {
        let targetElement = mutation.target;
        if (!["attributes", "childList"].includes(mutation.type) || mutation.type === "attributes" && mutation.attributeName !== "class" || targetElement.nodeType !== Node.ELEMENT_NODE || targetElement.id === _Runtime.styleElId || targetElement.classList.contains(_Runtime.ignoreClass) || targetElement.closest(ignoreSelector) !== null) {
          return;
        }
        targetElement = targetElement.cloneNode(true);
        targetElement.querySelectorAll(ignoreSelector).forEach((element) => {
          element.remove();
        });
        if (mutation.type === "attributes") {
          const contentToAdd = ` class="${targetElement.className}"`;
          if (!compilerContentQueue.includes(contentToAdd)) {
            compilerContentQueue += contentToAdd;
          }
        } else if (!compilerContentQueue.includes(targetElement.outerHTML)) {
          compilerContentQueue += targetElement.outerHTML;
        }
      });
      if (updateTimeout) {
        window.clearTimeout(updateTimeout);
      }
      if (!compilerContentQueue.trim().length) {
        return;
      }
      updateTimeout = window.setTimeout(() => {
        var _a;
        compilerContentQueue = (_a = this.updateCss(compilerContentQueue)) != null ? _a : "";
      }, this.repaintTimeout);
    });
    observer.observe(targetNode, config);
  }
  injectCss(css) {
    let el = document.getElementById(_Runtime.styleElId);
    if (el) {
      el.innerHTML = css;
    } else {
      el = document.createElement("style");
      el.id = _Runtime.styleElId;
      el.innerHTML = css;
      document.head.appendChild(el);
    }
    const elements = document.querySelectorAll(`.${_Runtime.cloakClass}`);
    elements.forEach((element) => {
      element.classList.remove(_Runtime.cloakClass);
      hooks.callHook("stylify:uncloak", { el: element });
    });
  }
};
var Runtime = _Runtime;
__publicField(Runtime, "styleElId", "stylify-css");
__publicField(Runtime, "ignoreClass", "stylify-ignore");
__publicField(Runtime, "cloakClass", "s-cloak");
export {
  CompilationResult,
  Compiler,
  CssRecord,
  CustomSelector,
  Hooks,
  MacroMatch,
  MinifiedSelectorGenerator,
  RegExpMatch,
  Runtime,
  backslashPlaceholder,
  createUId,
  defaultPreset,
  dollarPlaceholder,
  escapeCssSelector,
  getStringOriginalStateAfterReplace,
  hooks,
  lightenDarkenColor,
  mergeObjects,
  minifiedSelectorGenerator,
  parseColor,
  parseHex,
  parseRgb,
  prepareStringForReplace,
  rgbToHex,
  screensSorter,
  tokenize
};
